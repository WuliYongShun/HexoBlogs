---
title:  #pragma预处理指令
date: 2019-10-09 15:11:06
tags: 
- C++

categories: 
- YY
---

# #pragma预处理指令

***定义：***
在所有的预处理指令中，#pragma 指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。#pragma指令对每个编译器给出了一个方法，在保持与C和C++语言完全兼容的情况下，给出主机或操作系统专有的特征。依据定义，编译指示是机器或操作系统专有的，且对于每个编译器都是不同的。

***一般格式：***
#pargam Para        其中Para为参数

**举例**
*1.message参数：*
    Message 参数能够在编译信息输出窗口中输出相应的信息，这对于源代码信息的控制是非常重要的。其使用方法为：
    
   #pragma message("消息文本")
    
   当编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。
   当我们在程序中定义了许多宏来控制源代码版本的时候，我们自己有可能都会忘记有没有正确的设置这些宏，此时我们可以用这条指令在编译的时候就进行检查。假设我们希望判断自己有没有在源代码的什么地方定义了_X86这个宏可以用下面的方法
    #ifdef _X86
    #pragma message("_X86 macro activated!")
    #endif
当我们定义了_X86这个宏以后，应用程序在编译时就会在编译输出窗口里显示“_X86 macro activated! ”。我们就不会因为不记得自己定义的一些特定的宏而抓耳挠腮了。

*2.code_seg存放代码段：*

code_seg对pragma的使用量也比较大
#pragma code_seg(["section-name"[,"section-class"]])

它能够设置程序中函数代码存放的代码段，当我们开发驱动程序的时候就会使用到它。

3.pragma once 执行一次（常用）
    只要在头文件的最开始加入这条指令就能够保证头文件被编译一次，这条指令实际上在VC6中就已经有了，但是考虑到兼容性并没有太多的使用它。
    #pragma once是编译相关，就是说这个编译系统上能用，但在其他编译系统不一定可以，也就是说移植性差，不过现在基本上已经是每个编译器都有这个定义了。
    #ifndef，#define，#endif这个是C++语言相关，这是C++语言中的宏定义，通过宏定义避免文件多次编译。所以在所有支持C++语言的编译器上都是有效的，如果写的程序要跨平台，最好使用这种方式
    


附件链接：[pragma百度百科](https://baike.baidu.com/item/%23pragma/706691?fr=aladdin#1_10)


